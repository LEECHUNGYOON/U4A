/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
sap.ui.define(["./three"],function(t){"use strict";var e=function(t,e){"use strict";function r(t,r,n=true){if(!r||!r.isReady){throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.")}if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv")){throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.')}function o(t){if(t.normalized||t.isInterleavedBufferAttribute){const e=new Float32Array(t.count*t.itemSize);for(let r=0,n=0;r<t.count;r++){e[n++]=t.getX(r);e[n++]=t.getY(r);if(t.itemSize>2){e[n++]=t.getZ(r)}}return e}if(t.array instanceof Float32Array){return t.array}return new Float32Array(t.array)}const s=t.index?t.toNonIndexed():t;const i=r.generateTangents(o(s.attributes.position),o(s.attributes.normal),o(s.attributes.uv));if(n){for(let t=3;t<i.length;t+=4){i[t]*=-1}}s.setAttribute("tangent",new e.BufferAttribute(i,4));if(t!==s){t.copy(s)}return t}function n(t,r=false){const n=t[0].index!==null;const s=new Set(Object.keys(t[0].attributes));const i=new Set(Object.keys(t[0].morphAttributes));const u={};const a={};const f=t[0].morphTargetsRelative;const c=new e.BufferGeometry;let l=0;for(let e=0;e<t.length;++e){const o=t[e];let m=0;if(n!==(o.index!==null)){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");return null}for(const t in o.attributes){if(!s.has(t)){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.');return null}if(u[t]===undefined)u[t]=[];u[t].push(o.attributes[t]);m++}if(m!==s.size){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes.");return null}if(f!==o.morphTargetsRelative){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries.");return null}for(const t in o.morphAttributes){if(!i.has(t)){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries.");return null}if(a[t]===undefined)a[t]=[];a[t].push(o.morphAttributes[t])}if(r){let t;if(n){t=o.index.count}else if(o.attributes.position!==undefined){t=o.attributes.position.count}else{console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute");return null}c.addGroup(l,t,e);l+=t}}if(n){let e=0;const r=[];for(let n=0;n<t.length;++n){const o=t[n].index;for(let t=0;t<o.count;++t){r.push(o.getX(t)+e)}e+=t[n].attributes.position.count}c.setIndex(r)}for(const t in u){const e=o(u[t]);if(!e){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" attribute.");return null}c.setAttribute(t,e)}for(const t in a){const e=a[t][0].length;if(e===0)break;c.morphAttributes=c.morphAttributes||{};c.morphAttributes[t]=[];for(let r=0;r<e;++r){const e=[];for(let n=0;n<a[t].length;++n){e.push(a[t][n][r])}const n=o(e);if(!n){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" morphAttribute.");return null}c.morphAttributes[t].push(n)}}return c}function o(t){let r;let n;let o;let s=-1;let i=0;for(let e=0;e<t.length;++e){const u=t[e];if(u.isInterleavedBufferAttribute){console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.");return null}if(r===undefined)r=u.array.constructor;if(r!==u.array.constructor){console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");return null}if(n===undefined)n=u.itemSize;if(n!==u.itemSize){console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");return null}if(o===undefined)o=u.normalized;if(o!==u.normalized){console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");return null}if(s===-1)s=u.gpuType;if(s!==u.gpuType){console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");return null}i+=u.array.length}const u=new r(i);let a=0;for(let e=0;e<t.length;++e){u.set(t[e].array,a);a+=t[e].array.length}const f=new e.BufferAttribute(u,n,o);if(s!==undefined){f.gpuType=s}return f}function s(t){if(t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute){return u(t)}if(t.isInstancedBufferAttribute){return(new e.InstancedBufferAttribute).copy(t)}return(new e.BufferAttribute).copy(t)}function i(t){let r;let n=0;let o=0;for(let e=0,s=t.length;e<s;++e){const s=t[e];if(r===undefined)r=s.array.constructor;if(r!==s.array.constructor){console.error("AttributeBuffers of different types cannot be interleaved");return null}n+=s.array.length;o+=s.itemSize}const s=new e.InterleavedBuffer(new r(n),o);let i=0;const u=[];const a=["getX","getY","getZ","getW"];const f=["setX","setY","setZ","setW"];for(let r=0,n=t.length;r<n;r++){const n=t[r];const o=n.itemSize;const c=n.count;const l=new e.InterleavedBufferAttribute(s,o,i,n.normalized);u.push(l);i+=o;for(let t=0;t<c;t++){for(let e=0;e<o;e++){l[f[e]](t,n[a[e]](t))}}}return u}function u(t){const r=t.data.array.constructor;const n=t.count;const o=t.itemSize;const s=t.normalized;const i=new r(n*o);let u;if(t.isInstancedInterleavedBufferAttribute){u=new e.InstancedBufferAttribute(i,o,s,t.meshPerAttribute)}else{u=new e.BufferAttribute(i,o,s)}for(let e=0;e<n;e++){u.setX(e,t.getX(e));if(o>=2){u.setY(e,t.getY(e))}if(o>=3){u.setZ(e,t.getZ(e))}if(o>=4){u.setW(e,t.getW(e))}}return u}function a(t){const e=t.attributes;const r=t.morphTargets;const n=new Map;for(const t in e){const r=e[t];if(r.isInterleavedBufferAttribute){if(!n.has(r)){n.set(r,u(r))}e[t]=n.get(r)}}for(const t in r){const e=r[t];if(e.isInterleavedBufferAttribute){if(!n.has(e)){n.set(e,u(e))}r[t]=n.get(e)}}}function f(t){let e=0;for(const r in t.attributes){const n=t.getAttribute(r);e+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}const r=t.getIndex();e+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0;return e}function c(t,r=1e-4){r=Math.max(r,Number.EPSILON);const n={};const o=t.getIndex();const s=t.getAttribute("position");const i=o?o.count:s.count;let u=0;const a=Object.keys(t.attributes);const f={};const c={};const l=[];const m=["getX","getY","getZ","getW"];const d=["setX","setY","setZ","setW"];for(let r=0,n=a.length;r<n;r++){const n=a[r];const o=t.attributes[n];f[n]=new e.BufferAttribute(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);const s=t.morphAttributes[n];if(s){c[n]=new e.BufferAttribute(new s.array.constructor(s.count*s.itemSize),s.itemSize,s.normalized)}}const g=r*.5;const b=Math.log10(1/r);const h=Math.pow(10,b);const p=g*h;for(let e=0;e<i;e++){const r=o?o.getX(e):e;let s="";for(let e=0,n=a.length;e<n;e++){const n=a[e];const o=t.getAttribute(n);const i=o.itemSize;for(let t=0;t<i;t++){s+=`${~~(o[m[t]](r)*h+p)},`}}if(s in n){l.push(n[s])}else{for(let e=0,n=a.length;e<n;e++){const n=a[e];const o=t.getAttribute(n);const s=t.morphAttributes[n];const i=o.itemSize;const l=f[n];const g=c[n];for(let t=0;t<i;t++){const e=m[t];const n=d[t];l[n](u,o[e](r));if(s){for(let t=0,o=s.length;t<o;t++){g[t][n](u,s[t][e](r))}}}}n[s]=u;l.push(u);u++}}const A=t.clone();for(const r in t.attributes){const t=f[r];A.setAttribute(r,new e.BufferAttribute(t.array.slice(0,u*t.itemSize),t.itemSize,t.normalized));if(!(r in c))continue;for(let t=0;t<c[r].length;t++){const n=c[r][t];A.morphAttributes[r][t]=new e.BufferAttribute(n.array.slice(0,u*n.itemSize),n.itemSize,n.normalized)}}A.setIndex(l);return A}function l(t,r){if(r===e.TrianglesDrawMode){console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");return t}if(r===e.TriangleFanDrawMode||r===e.TriangleStripDrawMode){let n=t.getIndex();if(n===null){const e=[];const r=t.getAttribute("position");if(r!==undefined){for(let t=0;t<r.count;t++){e.push(t)}t.setIndex(e);n=t.getIndex()}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");return t}}const o=n.count-2;const s=[];if(r===e.TriangleFanDrawMode){for(let t=1;t<=o;t++){s.push(n.getX(0));s.push(n.getX(t));s.push(n.getX(t+1))}}else{for(let t=0;t<o;t++){if(t%2===0){s.push(n.getX(t));s.push(n.getX(t+1));s.push(n.getX(t+2))}else{s.push(n.getX(t+2));s.push(n.getX(t+1));s.push(n.getX(t))}}}if(s.length/3!==o){console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.")}const i=t.clone();i.setIndex(s);i.clearGroups();return i}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r);return t}}function m(t){const r=new e.Vector3;const n=new e.Vector3;const o=new e.Vector3;const s=new e.Vector3;const i=new e.Vector3;const u=new e.Vector3;const a=new e.Vector3;const f=new e.Vector3;const c=new e.Vector3;function l(t,e,l,m,d,g,b,h){r.fromBufferAttribute(e,d);n.fromBufferAttribute(e,g);o.fromBufferAttribute(e,b);const p=t.morphTargetInfluences;if(l&&p){a.set(0,0,0);f.set(0,0,0);c.set(0,0,0);for(let t=0,e=l.length;t<e;t++){const e=p[t];const h=l[t];if(e===0)continue;s.fromBufferAttribute(h,d);i.fromBufferAttribute(h,g);u.fromBufferAttribute(h,b);if(m){a.addScaledVector(s,e);f.addScaledVector(i,e);c.addScaledVector(u,e)}else{a.addScaledVector(s.sub(r),e);f.addScaledVector(i.sub(n),e);c.addScaledVector(u.sub(o),e)}}r.add(a);n.add(f);o.add(c)}if(t.isSkinnedMesh){t.applyBoneTransform(d,r);t.applyBoneTransform(g,n);t.applyBoneTransform(b,o)}h[d*3+0]=r.x;h[d*3+1]=r.y;h[d*3+2]=r.z;h[g*3+0]=n.x;h[g*3+1]=n.y;h[g*3+2]=n.z;h[b*3+0]=o.x;h[b*3+1]=o.y;h[b*3+2]=o.z}const m=t.geometry;const d=t.material;let g,b,h;const p=m.index;const A=m.attributes.position;const y=m.morphAttributes.position;const w=m.morphTargetsRelative;const B=m.attributes.normal;const E=m.morphAttributes.position;const T=m.groups;const x=m.drawRange;let z,G,I,S;let M;let V,R;const v=new Float32Array(A.count*A.itemSize);const U=new Float32Array(B.count*B.itemSize);if(p!==null){if(Array.isArray(d)){for(z=0,I=T.length;z<I;z++){M=T[z];V=Math.max(M.start,x.start);R=Math.min(M.start+M.count,x.start+x.count);for(G=V,S=R;G<S;G+=3){g=p.getX(G);b=p.getX(G+1);h=p.getX(G+2);l(t,A,y,w,g,b,h,v);l(t,B,E,w,g,b,h,U)}}}else{V=Math.max(0,x.start);R=Math.min(p.count,x.start+x.count);for(z=V,I=R;z<I;z+=3){g=p.getX(z);b=p.getX(z+1);h=p.getX(z+2);l(t,A,y,w,g,b,h,v);l(t,B,E,w,g,b,h,U)}}}else{if(Array.isArray(d)){for(z=0,I=T.length;z<I;z++){M=T[z];V=Math.max(M.start,x.start);R=Math.min(M.start+M.count,x.start+x.count);for(G=V,S=R;G<S;G+=3){g=G;b=G+1;h=G+2;l(t,A,y,w,g,b,h,v);l(t,B,E,w,g,b,h,U)}}}else{V=Math.max(0,x.start);R=Math.min(A.count,x.start+x.count);for(z=V,I=R;z<I;z+=3){g=z;b=z+1;h=z+2;l(t,A,y,w,g,b,h,v);l(t,B,E,w,g,b,h,U)}}}const X=new e.Float32BufferAttribute(v,3);const H=new e.Float32BufferAttribute(U,3);return{positionAttribute:A,normalAttribute:B,morphedPositionAttribute:X,morphedNormalAttribute:H}}function d(t){if(t.groups.length===0){console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.");return t}let e=t.groups;e=e.sort((t,e)=>{if(t.materialIndex!==e.materialIndex)return t.materialIndex-e.materialIndex;return t.start-e.start});if(t.getIndex()===null){const e=t.getAttribute("position");const r=[];for(let t=0;t<e.count;t+=3){r.push(t,t+1,t+2)}t.setIndex(r)}const r=t.getIndex();const n=[];for(let t=0;t<e.length;t++){const o=e[t];const s=o.start;const i=s+o.count;for(let t=s;t<i;t++){n.push(r.getX(t))}}t.dispose();t.setIndex(n);let o=0;for(let t=0;t<e.length;t++){const r=e[t];r.start=o;o+=r.count}let s=e[0];t.groups=[s];for(let r=1;r<e.length;r++){const n=e[r];if(s.materialIndex===n.materialIndex){s.count+=n.count}else{s=n;t.groups.push(s)}}return t}function g(t,r=Math.PI/3){const n=Math.cos(r);const o=(1+1e-10)*100;const s=[new e.Vector3,new e.Vector3,new e.Vector3];const i=new e.Vector3;const u=new e.Vector3;const a=new e.Vector3;const f=new e.Vector3;function c(t){const e=~~(t.x*o);const r=~~(t.y*o);const n=~~(t.z*o);return`${e},${r},${n}`}const l=t.index?t.toNonIndexed():t;const m=l.attributes.position;const d={};for(let t=0,r=m.count/3;t<r;t++){const r=3*t;const n=s[0].fromBufferAttribute(m,r+0);const o=s[1].fromBufferAttribute(m,r+1);const a=s[2].fromBufferAttribute(m,r+2);i.subVectors(a,o);u.subVectors(n,o);const f=(new e.Vector3).crossVectors(i,u).normalize();for(let t=0;t<3;t++){const e=s[t];const r=c(e);if(!(r in d)){d[r]=[]}d[r].push(f)}}const g=new Float32Array(m.count*3);const b=new e.BufferAttribute(g,3,false);for(let t=0,e=m.count/3;t<e;t++){const e=3*t;const r=s[0].fromBufferAttribute(m,e+0);const o=s[1].fromBufferAttribute(m,e+1);const l=s[2].fromBufferAttribute(m,e+2);i.subVectors(l,o);u.subVectors(r,o);a.crossVectors(i,u).normalize();for(let t=0;t<3;t++){const r=s[t];const o=c(r);const i=d[o];f.set(0,0,0);for(let t=0,e=i.length;t<e;t++){const e=i[t];if(a.dot(e)>n){f.add(e)}}f.normalize();b.setXYZ(e+t,f.x,f.y,f.z)}}l.setAttribute("normal",b);return l}function b(t,e=false){console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().");return n(t,e)}function h(t){console.warn("THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().");return o(t)}t.computeMikkTSpaceTangents=r;t.computeMorphedAttributes=m;t.deepCloneAttribute=s;t.deinterleaveAttribute=u;t.deinterleaveGeometry=a;t.estimateBytesUsed=f;t.interleaveAttributes=i;t.mergeAttributes=o;t.mergeBufferAttributes=h;t.mergeBufferGeometries=b;t.mergeGeometries=n;t.mergeGroups=d;t.mergeVertices=c;t.toCreasedNormals=g;t.toTrianglesDrawMode=l;return t}({},t);return e});
//# sourceMappingURL=BufferGeometryUtils.js.map